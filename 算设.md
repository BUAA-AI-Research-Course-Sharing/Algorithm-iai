# 算设串讲

**Pasonwang 2021.**

## 引言

### 如何评价算法

空间与时间，最优、平均与最差

$O,\Omega,\Theta$渐进符号描述了一个算法时空的复杂度的**无穷大**

例子：
$$
\log_{10}n,\sin n, 10^{10},\sum_{i=1}^n i^k(k\ge1),\sum_{i=1}^n\frac 1 i
$$
利用递推式计算复杂度，一般形式：
$$
T(n) = aT(\lfloor n/b\rfloor)+O(n^d)
$$

### 计算方法

1. 递归树
2. 代入法
3. **主定理**

主定理：

若
$$
T(n) = aT(\lfloor n/b\rfloor)+O(n^d)
$$
且式中$a>0$，$b>1$，$d\ge0$，则：
$$
T(n)=\left\{
\begin{aligned}
&O(n^d),&d>\log_ba\\
&O(n^d\log n), &d=\log_ba\\
&O(n^{\log_ba}),&d<\log_ba
\end{aligned}
\right.
$$
例子：
$$
T(1) = T(2) = 1\\
T(n) = T(n − 2) + 1,\quad if\ n > 2
$$

$$
T(1)  = 1\\
T(n) = T(n/2) + \log n,\quad if\ n > 1
$$

## 分治

分治基于主定理，构建一棵宽度、深度相适应的搜索树，使得整体问题的复杂度降低。

分：将问题分为若干小问题，子问题的解对整体问题的影响越小越好。

治：解决子问题。 

合：综合子问题的解，得到综合的、整体的答案。

### 逆序对问题

判断一个序列中，$a_i>a_j$而$i<j$的$(i,j)$对数。

这个问题可以二分计算，因为将数组某一半的逆序对个数计算出来，并不影响这一半与另一半的逆序对个数。同时，对某一半进行任意操作后，不影响$i$，$j$在不同组时，仍然是否是逆序对。

因此可以计算前一半的逆序对后，排序，再计算另一半，最后将两半的结果合起来。

伪代码如下：

```pseudocode
if i == j then
	return ([a[i]],0)
else
    ans = 0
    m = (i + j) / 2
    (s1,ans1) = Inverse(a[],i,m)
    (s2,ans2) = Inverse(a[],m+1,j)
    \\这时a[i...m],a[m+1...j]有序
    l = i, r = m + 1,
    while l != m && r != j do
        if a[l] < a[r] then
            将a[l]置于s数组最后
            l ++
        else
        	将a[l]置于s数组最后
            r ++
            ans += m - l - 1\\为此时前半段长度
        end
    end
    if l == m then
    	将a[r...j]置于s数组最后
    else
    	将a[l...m]置于s数组最后
    return s[],ans+ans1+ans2
end
```

由于前后两半有序，则排序是$O(n)$的。

递推式$T(n) = 2T(\lfloor n/2\rfloor)+O(n)$

由主定理，复杂度为$O(n\log n)$。

### 字符串等价关系判定

给定两个长度为$n$的字符串 $A$ 和 $B$，若称 $A$ 与 $B$ 是等价的，当且仅当它们满足如下关系之一： 

1.  $A$ 和 $B$ 完全相同;
2. 若将把 $A$ 分成长度相等的两段 $A1$ 和 $A2$，也将 $B$ 分成长度相等的两段 $B1$ 和 $B2$。且他们之间满足如下两种关系之一： a. $A1$ 和 $B1$ 等价且 $A2$ 和 $B2$ 等价; b. $A1$ 和 $B2$ 等价且 $A2$ 和 $B1$ 等价。 

请你设计一个高效的算法来判断两个字符串是否等价并分析你的算法的时间复杂度。

找到子问题很简单。先注意这里的等价是有传递性的，则可以根据此优化子问题的结构。

### 平面间上的最接近点对

给定平面上$n$个点，找出其中的一对点的距离，使得在这$n$个点的所有点对中，该距离为所有点对中最小的。

*BruteForce:*比较，爆搜，$O(n^2)$

## 动态规划

动态规划是很难、极富变化的一章。 

动态规划本质是将问题不同状态的最优解记录下来，再通过状态转移方程将状态进行转移。

如果需要记录方案，则需要在转移状态时记录状态。

最后需要判断边界条件和目标状态。 

即五步：设计状态、状态转移、记录方案、边界条件与目标状态。

简单起见，本章仅写状态转移方程，代码略。

其中前7题为线性dp，后3题为区间dp。

### [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

问题：给定一个三角形，找出自顶向下的最小路径和。一步只能移动到下一行中相邻的结点上。相邻的结点指下标与上一层结点下标相同或者等于上一层结点下标$+ 1 $的两个结点。也就是说，如果正位于当前行的下标$ i $，那么下一步可以移动到下一行的下标$ i $或$ i + 1 $。

![image-20211111100704714](C:\Users\surafce book2\AppData\Roaming\Typora\typora-user-images\image-20211111100704714.png)

设计状态：设$f[i][j]$为从$1$到$i$层第$j$个元素最小路径和。 

状态转移： 
$$
f[i][j] = \min(f[i-1][j],f[i-1][j-1]) + a[i][j]
$$
记录方案：记$pre[i][j]$为更新后前一个下标$j^{'}$ 

边界条件： $f[0][j]=0$

目标状态： $\min_jf[n][j]$ 

复杂度：$O(n^2)$

### 背包问题

问题：一个背包容量为$W$，有$n$个物品，第$i$个物品体积、价值分别为$v[i]$,$w[i]$，每个物品要么不装，要么仅装一个，问能装的最大价值为 

设计状态：设$f[i][j]$为仅考虑前$i$个物品，背包容量为$j$时的value最大值。 

状态转移：
$$
f[i][j] = \left\{
\begin{aligned}
&\max(f[i-1][j-v[i]]+w[i],f[i-1][j]),&j\ge v[i]\\
&f[i-1][j], &j<v[i]
\end{aligned}
\right.
$$
记录方案：可以记$pre[i][j]$表示$f[i][j]$是由什么状态转移来的，如果是$f[i-1][j-v[i]]$，记为1，否则置0即可。 

边界条件： $f[0][j]=f[i][0]=0$

目标状态：$f[n][W]$ 

最后分析复杂度，应为$O(nW)$。 

本题可以将空间复杂度换成$O(n)$，但空间复杂度不为考试要求，故略。

### LIS

问题：一个序列，找出它最长上升子序列长度，其中子序列不需要连续。 

设计状态：设$f[i]$为$s$从$1$到$i$最长公共子序列长度。 

状态转移： 
$$
f[i] = \max_{s[j]<s[i] 且 1\leq j <i}(f[j]+1)
$$
记录方案：记$pre[i]$为更新后前一个下标$j$ 

边界条件： $f[1]=1$

目标状态： $f[n]$ 

复杂度：$O(n^2)$

### LCS

问题：两个序列，找出他们最长公共子序列长度，其中子序列不需要连续 

设计状态：设$f[i][j]$为$s1$从$1$到$i$和$s2$从$1$到$j$最长公共子序列长度。 

状态转移： 
$$
f[i][j] = \left\{
\begin{aligned}
&f[i-1][j-1],&s1[i]=s2[j]\\
&\max(f[i-1][j]+f[i][j-1]), &s1[i]\ne s2[j]
\end{aligned}
\right.
$$
记录方案：对于三种状态分别记$pre[i][j]$为$1$，$2$，$3$. 

边界条件： $f[1][j]=f[i][1]=i$

目标状态： $f[n][m]$ 

复杂度：$O(nm)$

### MED

问题：两个串，记三种操作：加、删、改，问将第一个串编辑为第二个串的最少操作次数为

设计状态：设$f[i][j]$为$s1$从$1$到$i$和$s2$从$1$到$j$最小编辑距离。 

状态转移： 


$$
f[i] = \min\left(\underbrace {f[i-1][j]}_{加}, \underbrace{f[i][j-1]}_{删},\underbrace{\left\{\begin{aligned}&f[i-1][j-1] - 1,&s1[i]=s2[i]\\
&f[i-1][j-1],&s1[i]\ne s2[i]
\end{aligned}\right.}_{改}\right)+1
$$
记录方案：一共四种状态，记$pre[i][j]$为1，2，3，4即可。

边界条件： $f[1][i]=f[i][1] = i$

目标状态： $f[n][m]$ 

复杂度：$O(nm)$  	

### 最大路径法

问题：将一句话分成若干个词语或单字，其中词语可以在词典$dic$中查询，查询可以按$O(1)$计算，求分出词语和单字两者和最小的分词结果。

例如：如果放到回收站中将出错

分词结果：

[['如果']，['放']，['到']，['回收站']，['中']，['将']，['出错']]

[['如果']，['放']，['到']，['回收站']，['中将']，['出错']]

则第二个分词效果更好。

设计状态：设$f[i]$为从第一个字到$i$个字最少切分数量。 

状态转移： 


$$
f[i] = \min_{1\le j< i}\left\{\begin{aligned}&f[j] + 1, &\mathrm{text}[j:i] \in \mathrm{dic}\\
&f[j]+(i-j),&\mathrm{text}[j:i]\notin\mathrm{dic}
\end{aligned}\right.
$$
记录方案：记$pre[i]$为第$i$个字作为分词末尾的分词头下标. 

边界条件： $f[1]=1$

目标状态： $f[n]$ 

复杂度：$O(n)$

```python
def shortestPath(text:str) -> list:
    l = len(text)
    ans = []
    f = [1e10 for __ in range(0, l + 1 )]
    next = [i + 1 for i in range(0, l)]
    f[0] = 0
    
    for i in range(0, l):
        for j in range(i + 1, l + 1):
            dist = 1e10
            if j - i == 1:
                dist = 1
            if text[i:j] in dic:
                dist = f[i] + 1
            if dist < f[j]:
                f[j] = dist
                next[i] = j
    k = 0
    while k != l:
        ans.append((k, next[k]))
        k = next[k]
    return ans
```

### [鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

问题：$k$个相同鸡蛋，一栋高为$n$的楼，已知存在楼层$f$，$0\le f\le n$，任何高于$f$层落下的鸡蛋会碎，任意不高于$f$层落下的鸡蛋不会破。若鸡蛋在实验中碎了就不能再被使用，否则可以**重复使用**。求$f$与最小操作次数。

设计状态：设$f[i][j]$为从$1$到$i$层用$j$个鸡蛋的最小操作次数。 

状态转移： 
$$
f[i][j] = \min_{0\le j\le n}(\max_{0\le p\le j}(f[i-p][j]+f[i-1][j-1]) + 1)
$$
记录方案：记$pre[i][j]$为更新后前一个下标$p$，与具体使用的方法。 

边界条件： $f[0][j]=0,f[i][1] = i$

目标状态： $f[f][k]$ 

复杂度：$O(kn^2)$

### 矩阵链乘

问题：若干矩阵做乘法，怎么加括号使得乘法计算次数最少

设计状态：设$f[i][j]$为第$i$个矩阵乘到第$j$个矩阵的最少乘法计算次数。 

状态转移：
$$
f[i][j] = \left\{
\begin{aligned}
&0,&i=j\\
&\min_{i\le k<j}(f[i][k]+f[k+1][j]+p_{i-1}p_kp_j), &i<j
\end{aligned}
\right.
$$
式中数组$p$的意义为：矩阵$A_i$是一个$p[i-1]$行$p[i]$列矩阵。

记录方案：可以记$pre[i][j]$表示$f[i][j]$是由什么状态转移来的，如果是$k$，记为$k$。

边界条件： $f[i][i]=0$

目标状态：$f[1][n]$ 

最后分析复杂度，应为$O(n^3)$。 

### [石子合并](https://www.luogu.com.cn/problem/P1880)

问题：一排石子，每次合并将相邻两堆合成一堆，能获得新的一堆中石子数量的和的得分，问最大得分为？

设计状态：设$f[i][j]$为区间$[i,j]$内所有石子合并到一起的最大得分

状态转移：
$$
f[i][j] = \max_{i\le k<j}(f[i][k] + f[k+1][j] + \sum_{t=i}^ja_t)
$$
记录方案：可以记$pre[i][j]$表示$f[i][j]$是由什么状态转移来的，如果是$k$，记为$k$。

边界条件： $f[i][i]=0$

目标状态：$f[1][n]$ 

最后分析复杂度，应为$O(n^3)$。 

也可以贪心。

### [戳气球](https://leetcode-cn.com/problems/burst-balloons/)(考试题)

问题：有 $n$ 个气球，编号为$0$ 到$n - 1$，每个气球上都标有一个数字，戳破某个气球，可以获得该气球与相邻两个气球上数字的乘积的积分，求能获得的最大积分。（若戳第一个或最后一个，则只有两个数相乘）

补充：记$a[-1]=a[n]=1$

设计状态：设$f[i][j]$为区间$(i,j)$内所有石子合并到一起的最大得分

状态转移：
$$
f[i][j] = \max_{i< k<j}(f[i][k] + f[k][j] + a[i]a[k]a[j])
$$
记录方案：可以记$pre[i][j]$表示$f[i][j]$是由什么状态转移来的，如果是$k$，记为$k$。

边界条件： $\forall i\ge j-1,\ f[i][j]=0$

目标状态：$f[0][n+1]$ 

最后分析复杂度，应为$O(n^3)$。 

## 贪心算法

贪心算法难点基本有两点：一是判断一个问题是贪心问题还是其它问题，第二就是证明策略。这需要对最优子结构掌握较为熟练。 

开始时先拿几个例子试试，先找出最优的方法是啥。

本部分难点在于证明，故选择了少量题目，仅展示具体题目证明的思考。 

贪心算法的本质就是在每个选择中都保持最优，但最后得到的解一般不是最优解，因此贪心算法证明显得格外重要。贪心算法是个人都能找到，但证明正确性就很难了。

如何证明？一般方法如下：

1. 微扰法（邻项交换）：证明在任意状态下，任何对局部最优策略的微小改变都会造成整体结果变差。这种方法在排序贪心的正确性证明中常用。例如[活动选择问题](###活动选择问题)。排序问题一般使用排序不等式进行证明。有时也会用相邻项交换，证明可以参考冒泡排序正确性证明。
2. 范围缩放：证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差。例如[合并果子（改版）](###合并果子（改版）)
3. 决策包容性：证明在任意状态下，做出局部最优策略之后，在问题状态空间中的可达集合包含了作出其它任何决策后的可达集合。即：这个局部最优策略提供的可能性包含其它所有策略提供的可能性。例如[跳跃游戏](###跳跃游戏)
4. 反证法。例如[加油站]()
5. 数学归纳法

### 分数背包问题

问题：一个背包容量为$W$，有$n$个物品，第$i$个物品体积、价值分别为$v[i]$,$w[i]$，每个物体可带一部分，问能装的最大价值为？ 

贪心策略：考虑价重比，每次仅需要选价重比最优的即可。 

证明：不失一般性，认为物品下标以价重比由大到小排序。 

设任意方案$P^{'}$，设贪心方案为$P$ ,第$i$个物品取$x_i$份，对应的， 方案$P^{'}$的为$y_i$份，则显然有$\sum x_i=\sum y_i - \min (n,W)$，否则随便拿一点其它物品即可得到更大的价值。两式做差，有： 
$$
\sum (x_i-y_i)w_i=\sum x_iw_i-\sum y_iw_i
$$
由排序不等式，因为$x_i$、 $w_i$均为由大到小排序，因此上式大于等于0，当且仅当$y_i$由大到小排序时取等号。因此$P$ 为最优方案。得证。 

伪代码略。

复杂度显然为排序复杂度，$O(n\log n)$。

### 活动选择问题

问题：一系列活动，给出开始结束时间$s[i]$,$t[i]$，问能参加的最多活动数为？

怎样才能活动参加的最多呢？比如有许多npy等着圣诞节约会，如何选择尽可能多的呢？当然选择早完事早好，早完事就有更多时间选择了。因此贪心策略如下： 选择最早结束的活动。 

证明：不失一般性，假设活动时间下标按照结束时间前后排序。 

设该策略为$P$ ，若有一策略$P^{'}$更优，则$P^{'}$中至少有一个活动，结束时间比$P$中晚，否则$P=P^{'}$。记第一个不同的活动在$P$，$P^{'}$中为$a_i$，$b_i$ ，则$P^{'}$在$b_i$后完成的所有活动皆可由$P$完成，因为$P$中$a_i$完成的时间更早。因此$P$完成的个数应该大于等于$P^{'}$，从而 $P=P^{'}$，得证。

伪代码略。

复杂度显然为排序复杂度，$O(n\log n)$。

###  合并果子（改版）

问题：一排石子，每次合并将相邻两堆合成一堆，能获得新的一堆中石子数量的积的得分，问最大得分为？

答案显然合并果子

### 跳跃游戏

问题：一个非负整数数组$a$，初始位于0，数组每个元素代表该位置可跳跃的最大长度，求到达终点的最少步数（保证可以到达终点）

这一步跳哪？当然是看下一步跳哪更远，才能离终点更近啊！但是好像不太够，那如果看下下一步跳得更远呢？不妨证明一下：

证明：

设当前位置为$i$，则下一步可选范围为$[i+1, i+2, \dots, i+a[i]]$，则下下一步范围为$[i+2,i+3,\dots,\max_{i<k\le a[i]}(i+k+a[i+k])]$。该范围包含了下下一步的所有可能取值，由于该算法选择$\arg\max_{i<k\le a[i]}(i+k+a[i+k])$，则下一步的任意取值$k^{'}$，则任何$k^{'}$的下一步，$k$都能取到。因此走$k$的状态包含了其它任意点的状态，而$k$能达到最远，因此最优。$\square$

### 加油站

问题：一个环路上$n$个加油站，第$i$个加油站可加$a[i]$升汽油，第$i$个加油站去下一个加油站需要$b[i]$升汽油。问是否有一个加油站，使得从这里出发，能绕环路一周。

这个问题的关键是搜索几遍所有加油站？不妨想想，如果从$x$刚好到$y$而不能去$y+1$，那$x$到$y$之间任意一点，因为没有之前油的储备所以肯定去不了$y+1$，因此只需要整个环搜索一遍。如果搜索次数大于$n$就不行。

证明：

若当前$x$能达到的最远加油站为$y$，假设存在$x$与$y$间一座加油站$z$，使得$z$能到达加油站$y+1$。则：
$$
\sum_{i=z}^{j}b[i] < \sum_{i=z}^ja[i],\ \forall j\in (z,y+1]
$$
又因为$x$能到达加油站$z$，则有：
$$
\sum_{i=x}^{z}b[i] < \sum_{i=x}^za[i]
$$
两式相加，取$j=y+1$有：
$$
\sum_{i=x}^{y+1}b[i] < \sum_{i=x}^{y+1}a[i]
$$
这与当前$x$能达到的最远加油站为$y$矛盾！故原结论成立。$\square$

### 国王游戏

$n$个人，两只手，每只手上一**正整数**，从左往右站一排，最前面再额外站一个国王，国王两只手也有数字，每人得分为站在该人前面的所有人的左手上的数的乘积除以他自己右手上的数向下取整的结果。问得分最多的人最少获得多少金币？

这个贪心策略并不明显，先考虑两人情况：设第$i$个人（国王为0）左右手分别为$a[i]$，$b[i]$。则：

因为第一个人更前，因此：
$$
\max(a[0]/b[1], a[0]a[1]/b[2]) < \max(a[0]/b[2], a[0]a[2]/b[1])
$$
又因为所有数是正整数，所以
$$
1/b[1] \le a[2]/b[1],1/b[2]\le a[1]/b[2]
$$
看到乘除，其实也就两种，要么左右手乘，要么左右手除，找个数据试试发现好像是乘，那就反证法吧：

假设$a[0]a[1]/b[2]\ge a[0]a[2]/b[1]$，则有
$$
\max(a[0]/b[1], a[0]a[1]/b[2]) \le \max(a[0]/b[2], a[0]a[2]/b[1])
$$
因此$a[0]a[1]/b[2]< a[0]a[2]/b[1]$，即$a[1]b[1]<a[2]b[2]$。

对于$n$个人的证明，只需要把$a[0]$换成前$i-1$个人的左手乘积即可，转化成扰动法的证明。